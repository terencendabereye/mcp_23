$date
	Sun May  7 22:21:43 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module control_unit_tb $end
$var wire 16 ! operand [15:0] $end
$var wire 16 " reg_ans [15:0] $end
$var wire 16 # reg_b [15:0] $end
$var wire 4 $ reg_addr_to [3:0] $end
$var wire 4 % reg_addr_from [3:0] $end
$var wire 16 & reg_a [15:0] $end
$var wire 1 ' mov_enable $end
$var wire 1 ( mem_write $end
$var wire 1 ) mem_enable $end
$var wire 16 * mem_data [15:0] $end
$var wire 16 + mem_addr [15:0] $end
$var wire 1 , clk $end
$scope module A1 $end
$var wire 16 - operation [15:0] $end
$var wire 16 . y [15:0] $end
$var wire 16 / x [15:0] $end
$var reg 16 0 ans [15:0] $end
$var reg 1 1 did_overflow $end
$var reg 1 2 is_negative $end
$var reg 1 3 is_zero $end
$upscope $end
$scope module C1 $end
$var reg 1 , clk $end
$upscope $end
$scope module CU1 $end
$var wire 1 , clk $end
$var wire 16 4 mem_data [15:0] $end
$var reg 16 5 mem_addr [15:0] $end
$var reg 1 ) mem_enable $end
$var reg 1 ( mem_write $end
$var reg 1 ' mov_enable $end
$var reg 16 6 operand [15:0] $end
$var reg 4 7 reg_addr_from [3:0] $end
$var reg 4 8 reg_addr_to [3:0] $end
$var integer 32 9 state [31:0] $end
$scope begin $ivl_for_loop1 $end
$var integer 32 : i [31:0] $end
$upscope $end
$upscope $end
$scope module M1 $end
$var wire 16 ; addr [15:0] $end
$var wire 1 ) enable $end
$var wire 1 ( write $end
$var wire 16 < data [15:0] $end
$scope begin $ivl_for_loop2 $end
$var integer 32 = i [31:0] $end
$upscope $end
$upscope $end
$scope module RB1 $end
$var wire 16 > alu_ans [15:0] $end
$var wire 16 ? alu_x [15:0] $end
$var wire 16 @ alu_y [15:0] $end
$var wire 1 , clk $end
$var wire 1 ' enable $end
$var wire 4 A from_addr [3:0] $end
$var wire 16 B input_reg [15:0] $end
$var wire 4 C to_addr [3:0] $end
$scope begin $ivl_for_loop0 $end
$var integer 32 D i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000 D
bx C
b0 B
bx A
bz @
bz ?
bx >
b1100100 =
b0 <
b0 ;
b100 :
b0 9
bx 8
bx 7
b0 6
b0 5
b0 4
x3
x2
x1
bx 0
bz /
bz .
b0 -
0,
b0 +
b0 *
1)
0(
0'
bz &
bx %
bx $
bz #
bx "
b0 !
$end
#1
b1100110110 *
b1100110110 4
b1100110110 <
b1 +
b1 5
b1 ;
1,
#2
0,
#3
b100001011 *
b100001011 4
b100001011 <
b10 +
b10 5
b10 ;
1'
b110 $
b110 8
b110 C
b11 %
b11 7
b11 A
1,
#4
0,
#5
b1 *
b1 4
b1 <
b11 +
b11 5
b11 ;
b1 9
b1011 $
b1011 8
b1011 C
b1010 %
b1010 7
b1010 A
0'
1,
#6
0,
#7
b100001100 *
b100001100 4
b100001100 <
b100 +
b100 5
b100 ;
b0 9
1'
b1 !
b1 -
b1 B
b1 6
1,
#8
b1 &
b1 /
b1 ?
0,
#9
b1 *
b1 4
b1 <
b101 +
b101 5
b101 ;
b1 9
b1100 $
b1100 8
b1100 C
b0 !
b0 -
b0 B
b0 6
0'
1,
#10
0,
#11
b1000000001011 *
b1000000001011 4
b1000000001011 <
b110 +
b110 5
b110 ;
b0 9
1'
b1 !
b1 -
b1 B
b1 6
1,
#12
02
13
01
b0 "
b0 >
b0 0
b1 #
b1 .
b1 @
0,
#13
b11111111 *
b11111111 4
b11111111 <
b111 +
b111 5
b111 ;
b1011 $
b1011 8
b1011 C
b1101 %
b1101 7
b1101 A
03
b10 "
b10 >
b10 0
b0 !
b0 -
b0 B
b0 6
1'
1,
#14
b11 "
b11 >
b11 0
b10 &
b10 /
b10 ?
0,
#15
b1000 +
b1000 5
b1000 ;
b100 "
b100 >
b100 0
0'
b11 &
b11 /
b11 ?
1,
#16
0,
#17
b1001 +
b1001 5
b1001 ;
1,
#18
0,
#19
b1010 +
b1010 5
b1010 ;
1,
#20
0,
#21
b1011 +
b1011 5
b1011 ;
1,
#22
0,
#23
b1100 +
b1100 5
b1100 ;
1,
#24
0,
#25
b1101 +
b1101 5
b1101 ;
1,
#26
0,
#27
b1110 +
b1110 5
b1110 ;
1,
#28
0,
#29
b1111 +
b1111 5
b1111 ;
1,
#30
0,
#31
bx *
bx 4
bx <
b10000 +
b10000 5
b10000 ;
1,
#32
0,
#33
b10001 +
b10001 5
b10001 ;
1,
#34
0,
#35
b10010 +
b10010 5
b10010 ;
1,
#36
0,
#37
b10011 +
b10011 5
b10011 ;
1,
#38
0,
#39
b10100 +
b10100 5
b10100 ;
1,
#40
0,
#41
b10101 +
b10101 5
b10101 ;
1,
#42
0,
#43
b10110 +
b10110 5
b10110 ;
1,
#44
0,
#45
b10111 +
b10111 5
b10111 ;
1,
#46
0,
#47
b11000 +
b11000 5
b11000 ;
1,
#48
0,
#49
b11001 +
b11001 5
b11001 ;
1,
#50
0,
